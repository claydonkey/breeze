diff a/math/src/main/scala/breeze/linalg/operators/DenseMatrixOps.scala b/math/src/main/scala/breeze/linalg/operators/DenseMatrixOps.scala	(rejected hunks)
@@ -50,23 +50,23 @@
   implicit object implOpMulMatrix_DMD_DMD_eq_DMD
   extends OpMulMatrix.Impl2[DenseMatrix[Double], DenseMatrix[Double], DenseMatrix[Double]] {
 
-    def apply(_a : DenseMatrix[Double], _b : DenseMatrix[Double]): DenseMatrix[Double] = {
+    def apply(_a: DenseMatrix[Double], _b: DenseMatrix[Double]): DenseMatrix[Double] = {
 
       require(_a.cols == _b.rows, "Dimension mismatch!")
 
       val rv: DenseMatrix[Double] = DenseMatrix.zeros[Double](_a.rows, _b.cols)
 
-      if(_a.rows == 0 || _b.rows == 0 || _a.cols == 0 || _b.cols == 0) return rv
+      if (_a.rows == 0 || _b.rows == 0 || _a.cols == 0 || _b.cols == 0) return rv
 
       // if we have a weird stride...
-      val a: DenseMatrix[Double] = if(_a.majorStride < math.max(if(_a.isTranspose) _a.cols else _a.rows, 1)) _a.copy else _a
-      val b: DenseMatrix[Double] = if(_b.majorStride < math.max(if(_b.isTranspose) _b.cols else _b.rows, 1)) _b.copy else _b
+      val a: DenseMatrix[Double] = if (_a.majorStride < math.max(if (_a.isTranspose) _a.cols else _a.rows, 1)) _a.copy else _a
+      val b: DenseMatrix[Double] = if (_b.majorStride < math.max(if (_b.isTranspose) _b.cols else _b.rows, 1)) _b.copy else _b
 
       blas.dgemm(transposeString(a), transposeString(b),
-        rv.rows, rv.cols, a.cols,
-        1.0, a.data, a.offset, a.majorStride,
-        b.data, b.offset, b.majorStride,
-        0.0, rv.data, 0, rv.rows)
+		 rv.rows, rv.cols, a.cols,
+		 1.0, a.data, a.offset, a.majorStride,
+		 b.data, b.offset, b.majorStride,
+		 0.0, rv.data, 0, rv.rows)
       rv
     }
     implicitly[BinaryRegistry[Matrix[Double], Matrix[Double], OpMulMatrix.type, Matrix[Double]]].register(this)
